# labEx3
McPAT and GEM5 study
# Βήμα 1

## Ερώτημα 1

Όπως βλέουμε στο αντίστοιχο paper, η επικύρωση του McPAT έγινε με την σύγκριση των αποτελεσμάτων του με πραγματικά δεδομένα από διάφορους επεξεργαστές και πιο συγκεκριμένα τους Niagara (90nm), Niagara2 (65nm), Xeon (65nm) και Alpha (180nm). Καθώς πρόκειται για επεξεργαστές με διαφορετικά χαρακτηριστικά σε συχνότητα, κατανάλωση ηλεκτρικού ρεύματος, δυνατότητα παραλληλισμού και multithreading καθώς και διαφορές στον τρόπο εκτέλεσης εντολών (σειριακά ή με διαφορετική σειρά εκτέλεσης από την προκαθορισμένη), γίνεται μια πιο ολοκληρωμένη έρευνα που επικυρώνει την αξιοπιστία του συστήματος προσομοίωσης για διαφορετικά μοντέλα αλλά και διαφορετικές γενιές μονάδων επεξεργασίας.


## Ερώτημα 2

Η κάθε μία από αυτές τις ενδείξεις αναφέρεται στην δαπανούμενη ισχύ μίας από τις κατηγορίες που εμφανίζονται σε κυκλώματα CMOS. Αρχικά η δυναμική κατανάλωση ισχύος εκφράζει την ενέργεια που καταναλώνεται κατά την φόρτιση και εκφόρτιση των χωρητικοτήτων των τρανζίστορ που συμβαίνουν κατά την αλλαγή της κατάστασής τους. Οι παράγοντες από τους οποίους εξαρτάται είναι το μέγεθος των χωρητικοτήτων, η τάση λειτουργίας των τρανζίστορ, η εναλλαγή τάσης κατά την αλλαγή καταστάσεων η συχνότητα του ρολογιού και η συχνότητα αλλαγής καταστάσεων του τρανζίστορ. Η κατανάλωση ισχύος βραχυκυκλώματος εκφράζει την ενέργεια που καταναλώνεται κατά την εναλλαγή καταστάσεων των τρανζίστορ ελέγχου ενός κυκλώματος (πχ ενός μετατροπέα DC σε AC) όπου δημιουργείται ένα στιγμιαίο βραχυκύκλωμα κατά το οποίο η τροφοδοσία είναι άμεσα συνδεδεμένη με τη γείωση. Η κατανάλωση ισχύος λόγω διαρροών ρεύματος εκφράζει την ενέργεια που καταναλώνεται εξαιτίας των διαρροοών που εμφανίζονται στην πύλη των CMOS, στο υπόστρωμα καθώς και στο ρεύμα διαρροής ανάμεσα στην πηγή και την εκροή κατά τη λειτουργία του CMOS στην κατάσταση off. Το μοντέλο χρησιμοποιεί τεχνικές εξοικονόμησης ενέργειας για την καλύτερη προσέγγιση λειτουργίας σύγχρονων συστημάτων που εφαρμόζουν τέτοιους μηχανισμούς. Συγκεκριμένα, χρησιμοποιεί την τεχνική clock gating (αποκοπή του σήματος ρολογιού από ορισμένα τμήματα του κυκλώματος για την πλήρη απενεργοπίησή τους όταν δεν χρησιμοποιούνται) για τη δυναμική κατανάλωση ισχύος και ορισμένα sleep states για τη μείωση της στατικής κατανάλωσης ισχύος. Διαφορετικά προγράμματα επιτρέπουν την εφαρμογή τέτοιων τεχνικών σε διαφορετικά επίπεδα άρα περιμένουμε να δούμε μεταβολλή στην καταναλισκόμενη ισχύ ανάλογα με το πρόγραμμα που εκτελείται. Τέλος, σε ότι αφορά τον χρόνο εκτέλεσης, εφόσον ένα πρόγραμμα έχει παρόμοιες απαιτήσεις κατά τα διαφορετικά στάδια εκτέλεσής του, η διάρκεια εκτέλεσης, αν και με την αύξησή της αυξάνει το συνολικό ενεργειακό κόστος, δεν θα έπρεπε να οδηγεί σε σημαντικές μεταβολές στην κατανάλωση ισχύος.


## Ερώτημα 3

Ως αποδοτικότητα ενέργειας θα ορίζαμε την καταναλισκόμενη ενέργεια για την εκτέλεση ενός συγκεκριμένου προγράμματος και συνεπώς δεν φτάνει μόνο η πληροφορία σχετικά με την καναλισκόμενη ισχύ. Έχοντας δύο επεξεργαστές με κατανάλωση ισχύος 25W και 35W αντίστοιχα, θα έπρεπε να γνωρίζουμε τον χρόνο εκτέλεσης ενός προγράμματος για να βγάλουμε αποτελέσματα σχετικά με το ποιος είναι ο πιο αποδοτικός καθώς E = Pt όπου Ε η συνολική ενέργεια, P η ισχύς και t ο χρόνος εκτέλεσης που δεν μας δίνεται από το McPAT. Έτσι θα μπορούσαμε για χρόνους εκτέλεσης 10s και 5s αντίστοιχα να έχουμε 25 * 10 = 250J για τον πρώτο και 35 * 5 = 175J για τον δεύτερο επεξεργαστή σε ότι αφορά κατανάλωση ενέργειας βγάζοντας έτσι το συμπέρασμα πως παρά την μεγαλύτερη ισχύ λειτουργίας, ο δεύτερος επεξεργαστής έχει μικρότερο ενεργειακό κόστος για την εκτέλεσση του ίδιου προγράμματος. Η ταχύτητα εκτέλεσης θα μπορούσε να υπολογιστεί από το μέσο CPI των δύο επεξεργαστών κατά την εκτέλεση του προγράμματος σε συνδυασμό με τη συχνότητα του ρολογιού του κάθε επεξεργαστή, κάτι το οποίο θα μας επέτρεπε να βγάλουμε συμπεράσματα σχετικά με την αποδοτικότητα του καθενός ως το πηλίκο της ταχύτητας αυτής προς την καταναλισκόμενη ισχύ. Ένας καλός μετρητής ενεργειακής αποδοτικότητας λοιπόν θα ήταν ο λόγος της συχνότητας του ρολογιού προς το γινόμενο CPI και κατανάλωσης ισχύος που μας δίνει τον αριθμό instructions per Joule ή καλύτερα instructions per watt-second ή αλλιώς σε FLOPS per watt.


## Ερώτημα 4

Αρχικά βέπουμε τα αποτελέσματα που μας δίνει το McPAT για τους δύο επεξεργαστές στο αρχείο [XEON - ARM A9 stats.txt](https://github.com/nicholasterzis/labEx3/files/7888512/XEON.-.ARM.A9.stats.txt). Παρατηρούμε πως η στατική κατανάλωση ισχύος του επξεργαστή XEON λόγω ρευμάτων διαρροής είναι μεγαλύτερη από την peak κατανάλωση ισχύος του ARM A9 που σημαίνει πως ακόμα και σε αδρανή κατάσταση ο XEON καταναλώνει περισσότερη ενέργεια στη μονάδα του χρόνου απ'ότι ο ARM A9 όταν βρίσκεται σε μια κανονική κατάσταση λειτουργίας. Έτσι, ακόμα και μετά την εκτέλεση του προγράμματος, εφόσον το σύστημα δεν απενεργοποιείται, ο XEON συνεχίζει να απαιτεί περισσότερη ενέργεια από τον ARM A9 κάτι που προφανώς και τον καθιστά λιγότερο αποτελεσματικό σε ότι αφορά την ενεργειακή απόδοση άσχετα από τη διάρκεια εκτέλεσης κάποιου προγράμματος.



# Βήμα 2


## Ερώτημα 1

Την επίδραση του delaay μπορούμε να την δούμε μέσα από τον συνολικό χρόνο εκτέλεσης καθώς αυτή είναι η τιμή που επηρεάζεται από το σύνολο των επιπλέον καθυστερήσεων στο σύστημα. Για να βρούμε την κατανάλωση ενέργειας μπορούμε να χρησιμοποιήσουμε και πάλι τον χρόνο εκτέλεσης από το gem5 σε συνδυασμό με την κατανάλωση ισχύος που μας δίνει το McPAT, παίρνοντας έτσι με το γινόμενό τους τη συνολική τιμή της καταναλισκόμενης ενέργειας κατά τη διεξαγωγή ενός benchmark. Προφανώς διαθέτουμε και το αντίστοιχο python script που μας δίνει κατευθείαν αυτή την τιμή λαμβάνοντας υπόψη τη συνολική δυναμική ισχύ και ισχύ διαρροών που καταναλώνει το σύστημα, όπως αυτές προκύπτουν από τον υπολογισμό στο McPAT. Αξίζει να σημειωθεί πως παρά το γεγονός πως οι τιμές κατανάλωσης ισχύος για core και l2 είναι ίδιες για όλα τα benchmarks, υπάρχχουν ορισμένα τμήματα του συστήματος που διαφοροποιούνται ανάλογα με το πρόγραμμα και γι'αυτό το συνολικό αποτέλεσμα κατανάλωσης ενέργειας που μας δίνει το παραπάνω python script, δεν είναι ίδιο για κάθε benchmark. Χρησιμοποιώντας όμως τις τιμές για Peak Power και Area από core και L2 αθροιστικά παίρνουμε τα ίδια αποτελέσματα ανεξάρτητα από το ποιο πρόγραμμα τρέχουμε κάθε φορά. 


## Ερώτημα 2

## Για διαφορετικές τιμές L1i και L1d έχουμε:


|Benchmarks|Peak Power|Area|
|---|---|---|
|32_64 |3.7820  | 9.0027 | 
|128_64 |5.1688 |14.1919|
|128_128 |5.7018  |16.5205|
|128_256 |6.1125 |18.0274|
|256_128| 6.0743 |18.1781|
|256_256  |6.4851 |19.6851|

*Για L1 Cache Size = 384 χρησιμοποιούμε τις τιμές για Area και Power που προκύπτουν από L1i = 256kB και L1d = 128kB καθώς θυμ΄ό΄΄μαστε πως η περίπτωση L1i = 128kB και L1d = 256kB μας δίνει το ίδιο σχεδόν CPI με την περίπτωση L1i = 128kB και L1d = 128kB οπότε δεν έχει νόημα η συγκεκριμένη αύξηση

### Διάγραμμα για area

![image](https://user-images.githubusercontent.com/47783647/150195974-a7d0273a-3d8f-4172-b82d-12483d665e76.png)



### Διάγραμμα για power

![image](https://user-images.githubusercontent.com/47783647/150194956-e311802e-1a21-45a1-9d50-853585fd790a.png)



## Αλλάζοντας την L2:

|Benchmarks|Peak Power|Area|
|---|---|---|
|32_64|3.7820| 9.0027 |   
|l21024|3.85068 |11.0873 |
|l22048|3.9559|14.3903|
|l24096| 4.0806|19.7942|


### Διάγραμμα για area

![image](https://user-images.githubusercontent.com/47783647/150197965-9d04ba90-4cb9-4cf1-96db-3938b0daf1b1.png)



### Διάγραμμα για power

![image](https://user-images.githubusercontent.com/47783647/150197030-561be430-5e3d-4a21-97dc-2acb58f0167d.png)



## Μεταβάλλοντας το Associativity των L1i και L1d:

|Benchmarks|Peak Power|Area|
|---|---|---|
|32_64|3.7820| 9.0027 | 
|l1assoc2|3.8067|9.0754|
|l1assoc4| 3.9169  | 8.8818|
|l1assoc4_8| 4.2097|9.8125|
|l1assoc8_4|4.0691|9.1551|


*Στην τιμή των area και power για associativity = 8 βάλαμε την τιμή για L1i_assoc = 8 και L1d_assoc = 4 γιατί για την περίπτωση L1i_assoc = 4 και L1d_assoc = 8 θυμόμαστε πως το CPI δεν αλλάζει άρα δεν έχουμε κάποιο λόγο να προτιμήσουμε τις συγκεκριμένες τιμές


### Διάγραμμα για area

![image](https://user-images.githubusercontent.com/47783647/150199685-87be3695-9065-4c83-879c-a0e33aa1f3b5.png)



### Διάγραμμα για power

![image](https://user-images.githubusercontent.com/47783647/150199005-29f852ce-b5aa-4635-bff6-664d5dc556c9.png)



## Μεταβάλλοντας το Associativity της L2:

|Benchmarks|Peak Power|Area|
|---|---|---|
|32_64|3.7820| 9.0027 | 
|l2assoc2|3.7820| 9.0018|
|l2assoc4|3.7823|9.0005|
|l2assoc8|3.7837| 9.0385|

### Διάγραμμα για area

![image](https://user-images.githubusercontent.com/47783647/150200425-8e4be5a3-1a61-4ab7-bc33-960c7a246caa.png)



### Διάγραμμα για power

![image](https://user-images.githubusercontent.com/47783647/150200350-e168084d-c20e-4dc4-9ae6-cc94e0b3682b.png)



## Αλλάζοντας το cache line size

|Benchmarks|Peak Power|Area|
|---|---|---|
|cls32|2.1716|6.9483  | 
|32_64|3.7820| 9.0027 |
|cls128|  8.1869|  20.9686|
|cls256| 24.4794|  49.9250|


### Διάγραμμα για area

![image](https://user-images.githubusercontent.com/47783647/150201344-a4a274c0-678c-4c4e-ab91-e1aed63a2f24.png)



### Διάγραμμα για power

![image](https://user-images.githubusercontent.com/47783647/150201271-971dbcba-bb7f-42e0-bef8-bd99f2772a22.png)



## Ερώτημα 3

Παρατηρούμε διαφορές σε ότι αφορά τη συνάρτηση κόστους που ορίσαμε στο πρηγούμενο μέρος κυρίως ως προς τη γραμμικότητα που υπήρχε εκεί, ενώ εδώ βλέπουμε αρκετά διαφορετικές καμύλες κατανάλωσης ισχύος και επιφάνειας για τα περισσότερα χαρακτηριστικά που αλλάζουμε, ενώ συγκεκριμένα για το Associativity τόσο για την L1 όσο και για την L2 παρατηρούμε μια διακύμανση κατά τη μεταβολή τους και όχι τη σταθερή αύξηση που είχαμε σε άλλα χαρακτηριστικά ή στις αντίστοιχες καμπύλες κόστους από το 2ο μέρος.


# Βιβλιογραφία

https://www.hpl.hp.com/research/mcpat/micro09.pdf
https://www.quora.com/What-is-the-activity-factor-which-is-related-to-power-dissipation-in-CMOS-1
https://asic-soc.blogspot.com/2008/04/short-circuit-power.html
https://www.sciencedirect.com/topics/computer-science/dynamic-power-dissipation
https://en.wikipedia.org/wiki/Clock_gating
https://www.hpl.hp.com/research/mcpat/McPATAlpha_TechRep.pdf

